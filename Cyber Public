import logging
from telethon import TelegramClient, events, errors
from telethon.errors.rpcerrorlist import ChatAdminRequiredError
from telethon.utils import get_display_name
import random
from telethon import events, Button
import os
from datetime import datetime
from telethon.tl.types import PeerChat, PeerUser
import asyncio
from telethon.tl.functions.messages import SendMessageRequest
from telethon.tl.types import Message, ReplyInlineMarkup
import tracemalloc
from telethon import TelegramClient, events
from telethon.tl.functions.channels import GetParticipantsRequest
from telethon.tl.types import ChannelParticipantsAdmins
from telethon import TelegramClient, events
from telethon.tl.types import ChatAdminRights, ChannelParticipantsAdmins
from telethon.tl.functions.channels import GetFullChannelRequest
from telethon import TelegramClient, events, Button
from telethon.tl.types import PeerUser, PeerChat, PeerChannel, ChannelParticipantsAdmins
from telethon.tl.types import PeerUser, PeerChat, PeerChannel, ChatBannedRights, ChannelParticipantsAdmins
from telethon.tl.functions.channels import EditBannedRequest
from datetime import timedelta
from telethon.tl.types import PeerUser, PeerChannel, ChatAdminRights, ChannelParticipantsAdmins
from telethon.tl.functions.channels import EditAdminRequest
from telethon.tl.types import PeerUser, PeerChannel, ChannelParticipantsAdmins, ChatBannedRights
from telethon.tl.types import User
from telethon.tl.types import ChannelParticipantsAdmins
from telethon.tl.types import ChatBannedRights, ChannelParticipantsAdmins, ChannelParticipantsSearch
from telethon.tl.types import InputPeerChannel
from telethon.tl.custom import Button
import pyrogram
from telethon import TelegramClient, events
from telethon.tl.functions.channels import GetFullChannelRequest, GetParticipantsRequest
from telethon.tl.types import PeerChat, PeerChannel, InputPeerChat, InputPeerChannel, ChannelParticipantsSearch, ChannelParticipant
from telethon.errors import ChatAdminRequiredError
from telethon import TelegramClient, events, types
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
from telethon.tl.functions.channels import GetParticipantRequest, EditBannedRequest
from telethon.tl.types import ChannelParticipantAdmin, ChannelParticipantCreator, ChatBannedRights, PeerChannel

tracemalloc.start()

# Set up Spotify credentials (replace with your credentials)
spotify_client_id = '05b81aec25774891b93983680bbf6c50'
spotify_client_secret = '5178875503954cd6b194597e7cb45459'

sp = spotipy.Spotify(auth_manager=SpotifyClientCredentials(client_id=spotify_client_id,
                                                           client_secret=spotify_client_secret))

# Your API ID and hash from my.telegram.org
api_id = "29090143"
api_hash = 'c39952e7a81610e46ac1868421cddd05'
bot_token = '6794150478:AAHQlcVUcXjbyretc3xNw38DkMw_jZDG0Fw'

# Initialize the Telegram client
client = TelegramClient('bot', api_id, api_hash)
bot = TelegramClient('bot_session', api_id, api_hash).start(bot_token=bot_token)

@client.on(events.NewMessage(pattern='/start'))
async def handle_start_command(event):
    sender = await event.get_sender()
    chat_id = event.message.peer_id
    
    # Fetch the username of the sender
    username = sender.username if sender.username else sender.first_name

    if isinstance(chat_id, PeerUser):
        # Respond in DM
        await client.send_message(chat_id, f'❤️Heyaa❤️! @{username} I am 🍁CyberChief🍁.....Type /help to see all the list of commands....And Add me in your group to use my fantastic features.....')
    else:
        # Respond in group chat
        photo = await client.download_profile_photo(sender.id)
        await client.send_file(chat_id, photo, caption=f'Hey ! @{username} I am Online. Type /help to see all my available features')

@client.on(events.NewMessage(pattern='/help'))
async def help_command(event):
    # Send a help message to the user
    help_text = """
**📌Help Menu📌**

**Commands List**

/start - to start the bot
/help - to get a list of commands
/setwelcome - to set welcome message for new users
/rules - see the rules set in the group by an moderators
/setrules - sets the necessary rules for the group
/remrules - select a rule no. to remove it
/promote - promotes a member in the group 
/demote - demotes a member in the group
/mute - muted the targeted person for the set time
/unmute - unmutes the muted user
/kick - kicks the targeted user from the group
/ban - bans the targeted user in the group 
/unban - unbans the banned🚫 user
/pin - 📌 pins important messages in the group
/unpin - unpins the pinned message 
/info - get the information of the replied user
/id - get the I'd of the replied user🙅
/mcount - counts the total number of members in the group
/afk - confirm others that you are away
/lock - 🔒 locks all members in the group except admins
/unlock - 🔓 unlocks the locked group
/joke - bot will tell a joke for fun
/rps - play rock paper scissors game
/roll - to roll a dice 🎲 
/tictactoe - play tictactoe against another member
/wordle - play a word guessing game 🎮 
/lead - see the leaderboard of wordle 🎯 
/play - play musics in livestream
/utag - tags all users in a group
"""
    await event.respond(help_text)

# Dictionary to store welcome messages per group
welcome_messages = {}

# Function to check if the user is an admin in the group
async def is_admin(chat, user_id):
    if chat.megagroup:
        async for admin in client.iter_participants(chat, filter=ChannelParticipantsAdmins):
            if admin.id == user_id:
                return True
    return False

@client.on(events.NewMessage(pattern='/setwelcome'))
async def set_welcome(event):
    chat = await event.get_chat()

    if not hasattr(chat, 'megagroup') or not chat.megagroup:
        await event.reply("This command only works with groups.")
        return

    if not await is_admin(chat, event.sender_id):
        await event.reply("You are not 🚫 authorized to use this command.")
        return

    welcome_message = event.message.text.split(' ', 1)
    if len(welcome_message) < 2:
        await event.reply("Please provide a welcome message after the command.")
        return

    welcome_messages[chat.id] = welcome_message[1]
    await event.reply(f"This welcome message has been set successfully ✅ in {chat.title}")

@client.on(events.ChatAction)
async def welcome_new_member(event):
    chat = await event.get_chat()
    new_user = await event.get_user()

    if event.user_joined or event.user_added:
        if chat.id in welcome_messages:
            welcome_text = welcome_messages[chat.id]
            user_link = f"[{new_user.first_name}](tg://user?id={new_user.id})"
            await client.send_message(
                event.chat_id,
                f"Hey👋 {user_link}, {welcome_text}",
                file=await client.download_profile_photo(chat.id)
            )
        else:
            user_link = f"[{new_user.first_name}](tg://user?id={new_user.id})"
            await client.send_message(
                event.chat_id,
                f"{user_link} just landed in {chat.title}"
            )
            
# Storage for group rules
group_rules = {}

# Function to check if a user is an admin
async def is_admin(chat_id, user_id):
    participants = await client.get_participants(chat_id, filter=ChannelParticipantsAdmins)
    for participant in participants:
        if participant.id == user_id:
            return True
    return False

# /rules command
@client.on(events.NewMessage(pattern='/rules'))
async def show_rules(event):
    if isinstance(event.peer_id, PeerUser):
        await event.reply("This command only works with groups.")
        return
    
    chat_id = event.chat_id
    if chat_id in group_rules and group_rules[chat_id]:
        rules_text = '\n'.join([f"{idx + 1}. {rule}" for idx, rule in enumerate(group_rules[chat_id])])
        await event.reply(
            f"📜 **Group Rules:**\n{rules_text}\n\n*Click on the button below to remove any rule or directly use /remrules*",
            buttons=[Button.inline("/remrules", data="remrules")]
        )
    else:
        await event.reply("No rules have been set in this group yet.")

# /setrules command
@client.on(events.NewMessage(pattern='/setrules'))
async def set_rules(event):
    if isinstance(event.peer_id, PeerUser):
        await event.reply("This command only works with groups.")
        return

    chat_id = event.chat_id
    sender_id = event.sender_id
    
    if not await is_admin(chat_id, sender_id):
        await event.reply("🚫 You're not authorized to use this command.")
        return

    rule = event.message.message.split(' ', 1)[1] if ' ' in event.message.message else ''
    if not rule:
        await event.reply("Please provide a rule to set.")
        return

    if chat_id not in group_rules:
        group_rules[chat_id] = []
    group_rules[chat_id].append(rule)

    await event.reply(f"✅ Rule added successfully!\n\n📜 **Current Rules:**\n{''.join([f'{idx + 1}. {r}\n' for idx, r in enumerate(group_rules[chat_id])])}")

# /remrules command
@client.on(events.NewMessage(pattern='/remrules'))
async def rem_rules(event):
    if isinstance(event.peer_id, PeerUser):
        await event.reply("This command only works with groups.")
        return

    chat_id = event.chat_id
    sender_id = event.sender_id
    
    if not await is_admin(chat_id, sender_id):
        await event.reply("🚫 You need to be an Admin to use this command.")
        return

    if chat_id in group_rules and group_rules[chat_id]:
        buttons = [
            Button.inline(f"Remove {idx + 1}", data=f"remove_{idx}")
            for idx in range(len(group_rules[chat_id]))
        ]
        await event.reply("Select the rule to remove:", buttons=buttons)
    else:
        await event.reply("No rules have been set in this group yet.")

# Handle button clicks
@client.on(events.CallbackQuery)
async def callback(event):
    data = event.data.decode('utf-8')

    if data == "remrules":
        sender_id = event.sender_id
        chat_id = event.chat_id
        
        if not await is_admin(chat_id, sender_id):
            await event.reply("🚫 You cannot access this.")
        else:
            buttons = [
                Button.inline(f"Remove {idx + 1}", data=f"remove_{idx}")
                for idx in range(len(group_rules.get(chat_id, [])))
            ]
            await event.edit("Select the rule to remove:", buttons=buttons)

    elif data.startswith("remove_"):
        index = int(data.split('_')[1])
        chat_id = event.chat_id
        if chat_id in group_rules and len(group_rules[chat_id]) > index:
            removed_rule = group_rules[chat_id].pop(index)
            await event.reply(f"✅ Rule {index + 1} removed successfully!")
            if group_rules[chat_id]:
                await event.edit("📜 **Current Rules:**\n" + ''.join([f'{idx + 1}. {r}\n' for idx, r in enumerate(group_rules[chat_id])]))
            else:
                await event.edit("All rules have been removed.")
        else:
            await event.reply("Invalid rule number.")

# Function to check if a user is an admin
async def is_admin(chat_id, user_id):
    participants = await client.get_participants(chat_id, filter=ChannelParticipantsAdmins)
    for participant in participants:
        if participant.id == user_id:
            return True
    return False

# /mute command
@client.on(events.NewMessage(pattern='/mute'))
async def mute_user(event):
    if isinstance(event.peer_id, PeerUser):
        await event.reply("This command only works with groups.")
        return

    chat_id = event.chat_id
    sender_id = event.sender_id

    if not await is_admin(chat_id, sender_id):
        await event.reply("🚫 You're not authorized to use this command.")
        return

    if not event.is_reply:
        await event.reply("Reply to a user to mute.")
        return

    reply_message = await event.get_reply_message()
    user_to_mute = reply_message.sender_id

    if not await is_admin(chat_id, user_to_mute):
        if user_to_mute == sender_id:
            await event.reply("You can't mute yourself.")
            return

        # Determine the mute duration
        duration = None
        if len(event.message.message.split()) > 1:
            duration_text = event.message.message.split(' ', 1)[1].strip().lower()
            if 'min' in duration_text:
                minutes = int(duration_text.split(' ')[0])
                duration = timedelta(minutes=minutes)
            elif 'hr' in duration_text:
                hours = int(duration_text.split(' ')[0])
                duration = timedelta(hours=hours)
            elif 'day' in duration_text:
                days = int(duration_text.split(' ')[0])
                duration = timedelta(days=days)

        mute_rights = ChatBannedRights(
            until_date=None if not duration else event.date + duration,
            send_messages=True
        )

        await client(EditBannedRequest(chat_id, user_to_mute, mute_rights))
        user = await client.get_entity(user_to_mute)
        await event.reply(f"Shhhh! [{user.first_name}](tg://user?id={user_to_mute}) has been muted 🔕.")

    else:
        await event.reply("Ehh! I don't have the permission to mute Admins.")

# /unmute command
@client.on(events.NewMessage(pattern='/unmute'))
async def unmute_user(event):
    if isinstance(event.peer_id, PeerUser):
        await event.reply("This command only works with groups.")
        return

    chat_id = event.chat_id
    sender_id = event.sender_id

    if not await is_admin(chat_id, sender_id):
        await event.reply("🚫 You're not authorized to use this command.")
        return

    if not event.is_reply:
        await event.reply("Reply to a muted user to unmute.")
        return

    reply_message = await event.get_reply_message()
    user_to_unmute = reply_message.sender_id

    if not await is_admin(chat_id, user_to_unmute):
        unmute_rights = ChatBannedRights(until_date=None, send_messages=False)
        await client(EditBannedRequest(chat_id, user_to_unmute, unmute_rights))
        user = await client.get_entity(user_to_unmute)
        await event.reply(f"Fine! [{user.first_name}](tg://user?id={user_to_unmute}) can speak 🗣️ again.")
    else:
        await event.reply("Admins can't be muted. Why are you trying to unmute them?")

# Function to check if a user is an admin
async def is_admin(chat_id, user_id):
    participants = await client.get_participants(chat_id, filter=ChannelParticipantsAdmins)
    for participant in participants:
        if participant.id == user_id:
            return True
    return False

# /promote command
@client.on(events.NewMessage(pattern='/promote'))
async def promote_user(event):
    if isinstance(event.peer_id, PeerUser):
        await event.reply("This command only works with groups.")
        return

    chat_id = event.chat_id
    sender_id = event.sender_id

    if not await is_admin(chat_id, sender_id):
        await event.reply("🚫 You're not authorized to use this command.")
        return

    if not event.is_reply:
        await event.reply("Reply to a user to promote.")
        return

    reply_message = await event.get_reply_message()
    user_to_promote = reply_message.sender_id

    if await is_admin(chat_id, user_to_promote):
        await event.reply("This user is already an admin.")
        return

    rights = ChatAdminRights(
        add_admins=False,
        invite_users=True,
        change_info=False,
        ban_users=True,
        delete_messages=True,
        pin_messages=True,
        manage_call=True
    )

    await client(EditAdminRequest(chat_id, user_to_promote, rights, rank='Admin'))
    user = await client.get_entity(user_to_promote)
    group = await client.get_entity(chat_id)
    await event.reply(f"[{user.first_name}](tg://user?id={user_to_promote}) has been promoted ☺️ in {group.title}.")

# /demote command
@client.on(events.NewMessage(pattern='/demote'))
async def demote_user(event):
    if isinstance(event.peer_id, PeerUser):
        await event.reply("This command only works with groups.")
        return

    chat_id = event.chat_id
    sender_id = event.sender_id

    if not await is_admin(chat_id, sender_id):
        await event.reply("🚫 You're not authorized to use this command.")
        return

    if not event.is_reply:
        await event.reply("Reply to a user to demote.")
        return

    reply_message = await event.get_reply_message()
    user_to_demote = reply_message.sender_id

    if not await is_admin(chat_id, user_to_demote):
        await event.reply("This user is not an admin.")
        return

    no_rights = ChatAdminRights(
        add_admins=False,
        invite_users=False,
        change_info=False,
        ban_users=False,
        delete_messages=False,
        pin_messages=False,
        manage_call=False
    )

    try:
        await client(EditAdminRequest(chat_id, user_to_demote, no_rights, rank=''))
        user = await client.get_entity(user_to_demote)
        group = await client.get_entity(chat_id)
        await event.reply(f"[{user.first_name}](tg://user?id={user_to_demote}) is now demoted in {group.title}.")
    except Exception as e:
        await event.reply("I can't demote this user. You can demote them manually if needed.")
        print(f"Error occurred: {e}")

# Function to check if a user is an admin
async def is_admin(chat_id, user_id):
    participants = await client.get_participants(chat_id, filter=ChannelParticipantsAdmins)
    for participant in participants:
        if participant.id == user_id:
            return True
    return False

# /kick command
@client.on(events.NewMessage(pattern='/kick'))
async def kick_user(event):
    if isinstance(event.peer_id, PeerUser):
        await event.reply("This command only works with groups.")
        return

    chat_id = event.chat_id
    sender_id = event.sender_id

    if not await is_admin(chat_id, sender_id):
        await event.reply("🚫 You're not authorized to use this command.")
        return

    if not event.is_reply:
        await event.reply("Reply to a user to kick them.")
        return

    reply_message = await event.get_reply_message()
    user_to_kick = reply_message.sender_id

    if await is_admin(chat_id, user_to_kick):
        await event.reply("Why are you forcing me? I don't have the permission to kick an admin.")
        return

    if user_to_kick == sender_id:
        await event.reply("Use /kickme to kick yourself.")
        return

    ban_rights = ChatBannedRights(
        until_date=None,
        view_messages=True,
        send_messages=True,
        send_media=True,
        send_stickers=True,
        send_gifs=True,
        send_games=True,
        send_inline=True,
        embed_links=True,
        send_polls=True,
        change_info=True,
        invite_users=True,
        pin_messages=True
    )

    await client(EditBannedRequest(chat_id, user_to_kick, ban_rights))
    user = await client.get_entity(user_to_kick)
    group = await client.get_entity(chat_id)
    await event.reply(f"[{user.first_name}](tg://user?id={user_to_kick}) is kicked from {group.title}.")

@client.on(events.NewMessage(pattern='/id', func=lambda e: e.is_group))
async def get_id(event):
    if event.reply_to_msg_id:
        replied_msg = await event.get_reply_message()
        replied_user = await event.client.get_entity(replied_msg.sender_id)
        replied_user_name = replied_user.first_name
        replied_user_id = replied_msg.sender_id
        await event.respond(f'Here is {replied_user_name}\'s id: {replied_user_id}')
        logging.info(f'ID command received from {event.sender_id}')
    else:
        await event.respond('Please reply to a message to get the user\'s ID.')

@client.on(events.NewMessage(pattern='/id', func=lambda e: not e.is_group))
async def id_private(event):
    await event.respond('This command only works in groups.')
    logging.info(f'ID command received from {event.sender_id} in private chat')

@client.on(events.NewMessage(pattern='/info'))
async def info_command(event):
    # Extract the command argument
    args = event.message.text.split(maxsplit=1)
    if len(args) > 1:
        username_or_id = args[1].strip()
    else:
        username_or_id = None

    # Check if the command is used in a group
    if not event.is_group and username_or_id is None:
        await event.reply('This command only works in Groups.')
        return

    user = None
    if event.reply_to_msg_id:
        # Command is used as a reply
        replied_message = await event.get_reply_message()
        user = replied_message.sender
    elif username_or_id:
        # Command includes username or user ID
        try:
            # Try to convert to integer for user_id or resolve username
            if username_or_id.isdigit():
                user_id = int(username_or_id)
                user = await client.get_entity(user_id)
            else:
                user = await client.get_entity(username_or_id)
        except Exception as e:
            await event.reply(f'Error fetching user: {e}')
            return

    if user and isinstance(user, User):
        user_info = await client.get_entity(user.id)
        
        # Prepare user information with styled box
        info_box = (
            "╔═══════════════════╗\n"
            "║           **User Information**         \n"
            "╠═══════════════════╣\n"
            f"║ ID: {user_info.id:<30} \n"
            f"║ First Name: {user_info.first_name:<22} \n"
            f"║ Last Name: {user_info.last_name if user_info.last_name else 'No Last Name':<22} \n"
            f"║ Username: @{user_info.username if user_info.username else 'No Username':<21} \n"
            f"║ User Link: [link](https://t.me/{user_info.username}){' ' * (29 - len(user_info.username) if user_info.username else '')} \n"
            "╚═══════════════════╝"
        )
        
        # Attempt to fetch the user's profile photo
        try:
            profile_photo = await client.download_profile_photo(user.id, download_big=True)
            # Send the profile photo and message as a reply to the original message
            await event.reply(info_box, parse_mode='markdown', file=profile_photo)
        except Exception:
            # Send the message without a profile photo if there was an error
            await event.reply(info_box, parse_mode='markdown')
    else:
        await event.reply('The replied message or username/user ID is not valid.')

# Function to check if a user is an admin
async def is_user_admin(client, group, user_id):
    admins = await client.get_participants(group, filter=ChannelParticipantsAdmins)
    return any(admin.id == user_id for admin in admins)

# Command handler for /mcount
@client.on(events.NewMessage(pattern='/mcount'))
async def mcount_handler(event):
    if event.is_private:
        await event.reply("This command only works in groups.")
        return

    sender_id = event.sender_id
    group = await event.get_chat()

    if not await is_user_admin(client, group, sender_id):
        await event.reply("You are not 🚫 authorized to use this command.")
        return

    # Fetch the full group/channel details
    full_group = await client(GetFullChannelRequest(group))
    participants = await client.get_participants(group)

    # Count members excluding bots
    member_count = sum(1 for user in participants if not user.bot)

    # Create a button for fetching usernames
    button = Button.inline("Get Usernames", data=f"get_usernames_{sender_id}")

    # Reply with the member count and group name
    await event.reply(f"There are {member_count} members in {group.title} (excluding bots).", buttons=[button])

# Callback query handler for the button
@client.on(events.CallbackQuery(pattern=r'get_usernames_(\d+)'))
async def callback_handler(event):
    group = await event.get_chat()
    sender_id = int(event.pattern_match.group(1))

    if event.sender_id != sender_id:
        await event.answer("You can't access this.", alert=True)
        return

    # Fetch participants again to list usernames
    participants = await client.get_participants(group)
    usernames = [f"@{user.username}" for user in participants if not user.bot and user.username]

    # Send the list of usernames or a message if no usernames exist
    if usernames:
        await event.edit("\n".join(usernames))
    else:
        await event.edit("No usernames found (excluding bots).")

# Global dictionary to track AFK users
afk_users = {}

# /afk command handler
@client.on(events.NewMessage(pattern='/afk ?(.*)'))
async def afk_handler(event):
    if not event.is_group:
        await event.reply('This command only works in groups.')
        return

    reason = event.pattern_match.group(1) or "No reason provided"
    user = await event.get_sender()
    afk_users[user.id] = {'reason': reason, 'time': datetime.now()}
    await event.reply(f'{user.first_name} is now away! Reason: {reason}')

# Auto-off AFK handler
@client.on(events.NewMessage())
async def auto_off_afk(event):
    user = await event.get_sender()

    if user.id in afk_users and not event.message.message.startswith('/afk'):
        del afk_users[user.id]
        await event.respond(f'Welcome back, {user.first_name}! Your AFK status is now off.')

    if event.message.entities or event.is_reply:
        if event.message.entities:
            for entity in event.message.get_entities_text():
                if isinstance(entity[0], int):
                    mentioned_user_id = entity[0]
                    if mentioned_user_id in afk_users:
                        afk_time = afk_users[mentioned_user_id]['time']
                        reason = afk_users[mentioned_user_id]['reason']
                        elapsed_time = datetime.now() - afk_time
                        elapsed_time_str = str(elapsed_time).split('.')[0]
                        await event.reply(f'The user you mentioned is currently AFK.\n'
                                          f'Reason: {reason}\n'
                                          f'AFK for: {elapsed_time_str}')

        if event.is_reply:
            replied_msg = await event.get_reply_message()
            replied_user_id = replied_msg.sender_id
            if replied_user_id in afk_users:
                afk_time = afk_users[replied_user_id]['time']
                reason = afk_users[replied_user_id]['reason']
                elapsed_time = datetime.now() - afk_time
                elapsed_time_str = str(elapsed_time).split('.')[0]
                await event.reply(f'The user you replied to is currently AFK.\n'
                                  f'Reason: {reason}\n'
                                  f'AFK for: {elapsed_time_str}')

# Initialize a dictionary to keep track of locked groups
locked_groups = {}

# Function to check if a user is an admin
async def is_user_admin(client, group, user_id):
    admins = await client.get_participants(group, filter=ChannelParticipantsAdmins)
    return any(admin.id == user_id for admin in admins)

# Command handler for /lock
@client.on(events.NewMessage(pattern='/lock'))
async def lock_handler(event):
    if event.is_private:
        await event.reply("This command only works in groups.")
        return

    sender_id = event.sender_id
    group = await event.get_chat()

    if not await is_user_admin(client, group, sender_id):
        await event.reply("You are not 🚫 authorized to use this command.")
        return

    # Lock the group: restrict sending messages for normal members
    participants = await client.get_participants(group)
    for user in participants:
        if not await is_user_admin(client, group, user.id):  # Ensure we are not restricting admins
            lock_rights = ChatBannedRights(until_date=None, send_messages=True)
            await client(EditBannedRequest(group, user.id, lock_rights))

    # Track that the group is locked
    locked_groups[group.id] = True

    # Notify members that the group is locked
    await event.reply("Admins have locked 🔒 the group. Only admins can send messages now.")

# Command handler for /unlock
@client.on(events.NewMessage(pattern='/unlock'))
async def unlock_handler(event):
    if event.is_private:
        await event.reply("This command only works in groups.")
        return

    sender_id = event.sender_id
    group = await event.get_chat()

    if not await is_user_admin(client, group, sender_id):
        await event.reply("You are not 🚫 authorized to use this command.")
        return

    if not locked_groups.get(group.id):
        await event.reply("The group is not locked 🔒.")
        return

    # Unlock the group: allow sending messages for normal members
    participants = await client.get_participants(group)
    for user in participants:
        if not await is_user_admin(client, group, user.id):  # Ensure we are not unlocking admins
            unlock_rights = ChatBannedRights(until_date=None, send_messages=False)
            await client(EditBannedRequest(group, user.id, unlock_rights))

    # Remove the group from locked groups
    locked_groups.pop(group.id, None)

    # Notify members that the group is unlocked
    await event.reply("Group unlocked 🔓. Now all users can speak 🗣️ freely.")

# List of English jokes
english_jokes = [
    "Why don't scientists trust atoms? Because they make up everything.",
    "Why don't eggs tell jokes? They'd crack each other up.",
    "Why did the tomato turn red? Because it saw the salad dressing!",
    # Add more English jokes here
]

# List of Hindi jokes
hindi_jokes = [
    "क्योंकि वे सब कुछ बनाते हैं, इसलिए वैज्ञानिक परमाणुओं पर विश्वास नहीं करते।",
    "क्योंकि वे एक दूसरे को तोड़ देंगे, इसलिए अंडे जोक्स नहीं बताते।",
    "क्योंकि सलाद ड्रेसिंग देखी, इसलिए टमाटर लाल हो गया!",
    # Add more Hindi jokes here
]

@client.on(events.NewMessage(pattern='/joke'))
async def joke(event):
    language = random.choice(['english', 'hindi'])
    if language == 'english':
        joke = random.choice(english_jokes)
    else:
        joke = random.choice(hindi_jokes)
    await event.respond(joke)
    logging.info(f'Joke command received from {event.sender_id}')

# Define the game data structure
game_data = {}

def mention(username):
    return f'[{username}](tg://user?id={username})'

@client.on(events.NewMessage(pattern='/rps'))
async def handle_rps(event):
    # Check if the command is used in a group
    if not event.is_group:
        await event.respond('Use /rps by replying to a user in a group to play Rock🥌, Paper📜, and Scissors✂️ with them.')
        return

    # Get the replied user
    replied_user = await event.get_reply_message()
    if not replied_user:
        await event.respond('Reply to a user to play Rock🥌, Paper📜, and Scissors✂️ with them.')
        return

    # Get the usernames of the players
    player1_username = event.sender.username
    player2_username = replied_user.sender.username

    # Initialize the game data
    game_data[event.chat_id] = {'player1': player1_username, 'player2': player2_username, 'choices': {}}

    # Send the game start message with buttons
    buttons = [
        Button.inline('Rock 🥌', data='rock'),
        Button.inline('Paper 📜', data='paper'),
        Button.inline('Scissors ✂️', data='scissors')
    ]
    await event.respond(f'{mention(player1_username)} vs {mention(player2_username)}\n{mention(player1_username)}, choose your move:', buttons=buttons)

@client.on(events.CallbackQuery)
async def handle_callback(event):
    # Get the game data
    game_data_chat_id = event.chat_id
    game_data_player = game_data[game_data_chat_id]['player1' if event.sender.username == game_data[game_data_chat_id]['player1'] else 'player2']

    # Get the user's choice
    choice = event.data.decode('utf-8')

    # Store the user's choice
    game_data[game_data_chat_id]['choices'][game_data_player] = choice

    # Check if it's player 1's turn
    if game_data_player == game_data[game_data_chat_id]['player1']:
        await event.respond(f'{mention(game_data[game_data_chat_id]["player1"])} has chosen. Let {mention(game_data[game_data_chat_id]["player2"])} choose their move.')
    else:
        # Determine the winner
        player1_choice = game_data[game_data_chat_id]['choices'][game_data[game_data_chat_id]['player1']]
        player2_choice = game_data[game_data_chat_id]['choices'][game_data[game_data_chat_id]['player2']]
        winner = determine_winner(game_data_chat_id, player1_choice, player2_choice)

        # Send the game result message
        await event.respond(f'{mention(game_data[game_data_chat_id]["player1"])} vs {mention(game_data[game_data_chat_id]["player2"])}\nWinner: {mention(winner)}')

def determine_winner(chat_id, player1_choice, player2_choice):
    if player1_choice == player2_choice:
        return 'It\'s a tie!'
    elif (player1_choice == 'rock' and player2_choice == 'scissors') or (player1_choice == 'scissors' and player2_choice == 'paper') or (player1_choice == 'paper' and player2_choice == 'rock'):
        return game_data[chat_id]['player1']
    else:
        return game_data[chat_id]['player2']

# /roll command handler
@client.on(events.NewMessage(pattern='/roll'))
async def roll(event):
    roll_message = await event.respond('Rolling the dice... 🎲')
    num_rolls = random.randint(3, 6)
    for i in range(num_rolls):
        await roll_message.edit(f'Rolling the dice... 🎲[{i+1}/{num_rolls}]')
        await asyncio.sleep(0.5)
    roll_result = random.randint(1, 6)
    await roll_message.edit(f'You rolled a {roll_result} 🎲')

# Dictionary to keep track of active games per user
active_games = {}

# Handle the /tictactoe command
@client.on(events.NewMessage(pattern='/tictactoe'))
async def tictactoe_handler(event):
    if event.is_private:
        await event.reply("Use this command in a group by replying to a user to play with them.")
        return
    
    if not event.is_reply:
        await event.reply("Reply to a user with /tictactoe to play with them.")
        return

    replied_user = await event.get_reply_message()
    user1 = event.sender
    user2 = replied_user.sender

    chat_id = event.chat_id
    user1_id = user1.id
    user2_id = user2.id

    # Check if the users are already in a game
    if user1_id in active_games:
        await event.reply("Finish your last game to start a new one or use /start to close your current game.")
        return

    if user2_id in active_games:
        await event.reply("The user you're trying to play with is already in a game.")
        return

    # Start a new game
    game_key = f"{chat_id}-{user1_id}-{user2_id}"
    active_games[game_key] = {
        'players': {user1_id: user1, user2_id: user2},
        'turn': user1_id,
        'board': ["⬜️", "⬜️", "⬜️", "⬜️", "⬜️", "⬜️", "⬜️", "⬜️", "⬜️"],
        'symbols': {}
    }

    # Add the game key to the players' active game records
    active_games[user1_id] = game_key
    active_games[user2_id] = game_key

    buttons = [
        [Button.inline('⭕', b'choose_o'), Button.inline('❌', b'choose_x')]
    ]

    user1_link = f"[{get_display_name(user1)}](tg://user?id={user1_id})"
    user2_link = f"[{get_display_name(user2)}](tg://user?id={user2_id})"

    await event.reply(f"{user1_link} and {user2_link}, choose your sides:", buttons=buttons, parse_mode='md')

@client.on(events.CallbackQuery)
async def callback_query_handler(event):
    chat_id = str(event.chat_id)
    user_id = event.sender_id

    if user_id not in active_games:
        await event.answer("No active game found for you.")
        return

    game_key = active_games[user_id]
    game = active_games[game_key]

    if not game['symbols']:
        # Let players choose their symbols
        if event.data == b'choose_o':
            game['symbols'][user_id] = '⭕'
            other_player_id = next(uid for uid in game['players'] if uid != user_id)
            game['symbols'][other_player_id] = '❌'
        elif event.data == b'choose_x':
            game['symbols'][user_id] = '❌'
            other_player_id = next(uid for uid in game['players'] if uid != user_id)
            game['symbols'][other_player_id] = '⭕'

        await event.edit("Sides chosen! Let the game begin.")
        await start_game(event, game_key)
        return

    # Handle player moves
    index = int(event.data.decode())
    if game['turn'] != user_id:
        await event.answer("Wait for your turn.")
        return

    if game['board'][index] != "⬜️":
        await event.answer("This spot is already taken.")
        return

    game['board'][index] = game['symbols'][user_id]
    game['turn'] = next(uid for uid in game['players'] if uid != user_id)

    winner = check_winner(game['board'])
    if winner:
        user_link = f"[{get_display_name(event.sender)}](tg://user?id={user_id})"
        await event.edit(f"Game over! {user_link} wins!", parse_mode='md')
        clean_up_game(game_key)
    elif "⬜️" not in game['board']:
        await event.edit("It's a draw!")
        clean_up_game(game_key)
    else:
        await start_game(event, game_key)

async def start_game(event, game_key):
    game = active_games[game_key]
    turn_user = game['players'][game['turn']]
    turn_user_link = f"[{get_display_name(turn_user)}](tg://user?id={turn_user.id})"
    board = "\n".join(["".join(game['board'][i:i+3]) for i in range(0, 9, 3)])
    buttons = [Button.inline(str(i+1), data=str(i)) if game['board'][i] == "⬜️" else Button.inline(game['board'][i], b'nothing') for i in range(9)]
    buttons = [buttons[i:i+3] for i in range(0, 9, 3)]

    await event.edit(f"Turn: {turn_user_link}\n\n{board}", buttons=buttons, parse_mode='md')

def check_winner(board):
    winning_combinations = [
        (0, 1, 2), (3, 4, 5), (6, 7, 8),  # Rows
        (0, 3, 6), (1, 4, 7), (2, 5, 8),  # Columns
        (0, 4, 8), (2, 4, 6)              # Diagonals
    ]

    for combination in winning_combinations:
        if board[combination[0]] == board[combination[1]] == board[combination[2]] != "⬜️":
            return True

    return False

def clean_up_game(game_key):
    game = active_games.pop(game_key, None)
    if game:
        for player_id in game['players']:
            active_games.pop(player_id, None)

# Global state storage, now per-user
game_state = {}
leaderboard = {}  # Store player scores

# Expanded list of words to use in the game
words = [
    'NARUTO', 'SASUKE', 'SAKURA', 'KAKASHI', 'HINATA', 
    'SHIKAMARU', 'INO', 'CHOJI', 'NEJI', 'TEN TEN', 
    'KIBA', 'KANKURO', 'GAARA', 'JIRAIYA', 'TSUNADE', 
    'OROCHIMARU', 'MINATO', 'KUSHINA', 'ITACHI', 'DEIDARA',
    'KURAMA', 'OBITO', 'MADARA', 'KONAN', 
    'PAPER', 'SHURIKEN', 'CLAN', 'NINJA', 'SAGE', 
    'JUTSU', 'CHAKRA', 'KAGE', 'BLOODLINE', 'RIVAL',
    'FRIEND', 'ENEMY', 'TRAINING', 'MISSION', 'VILLAGE',
    'ELEPHANT', 'TIGER', 'GIRAFFE', 'KANGAROO', 'PANDA',
    'BICYCLE', 'CAR', 'TRUCK', 'AIRPLANE', 'BOAT',
    'EARTHQUAKE', 'TSUNAMI', 'VOLCANO', 'HURRICANE', 'FLOOD',
    'MOUNTAIN', 'FOREST', 'DESERT', 'RIVER', 'OCEAN',
    'SUN', 'MOON', 'STAR', 'CLOUD', 'RAIN',
    'BEACH', 'FOREST', 'JUNGLE', 'WILDLIFE', 'CITY',
    'MUSEUM', 'LIBRARY', 'PARK', 'HOSPITAL', 'SCHOOL',
    'BOOK', 'MAGAZINE', 'NEWSPAPER', 'TEXTBOOK', 'NOTEBOOK',
    'PAINTER', 'SCULPTOR', 'ACTOR', 'MUSICIAN', 'WRITER',
    'COMPUTER', 'PHONE', 'TELEVISION', 'RADIO', 'CAMERA',
    'FOOD', 'DRINK', 'CAFE', 'RESTAURANT', 'CHEF',
    'LAPTOP', 'KEYBOARD', 'MOUSE', 'PRINTER', 'DESK',
    'GLOBE', 'MAP', 'TRAVEL', 'VACATION', 'HIKING',
    'SNOW', 'ICE', 'WIND', 'THUNDER', 'LIGHTNING',
    'COAST', 'HARBOR', 'DOCK', 'SHIP', 'FERRY',
    'ROBOT', 'AI', 'DRONE', 'GADGET', 'TECHNOLOGY',
    'ELECTRICITY', 'BATTERY', 'SOLAR', 'WINDMILL', 'HYDROPOWER'
]

# Choose a random word from the list
def get_random_word():
    return random.choice(words)

# Create a partially completed word with a random number of letters revealed
def create_puzzle(word, reveal_count=5):
    puzzle = ['_' for _ in range(len(word))]
    reveal_indices = random.sample(range(len(word)), reveal_count)
    for i in reveal_indices:
        puzzle[i] = word[i]
    return ''.join(puzzle)

# Create inline buttons for each letter in the alphabet
def create_buttons():
    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    buttons = [Button.inline(letter, data=letter) for letter in alphabet]
    button_rows = [buttons[i:i + 8] for i in range(0, len(buttons), 8)]
    return button_rows

@client.on(events.NewMessage(pattern='/pstart'))
async def start(event):
    await event.respond("Welcome to Word Forge! Type /wordle to start a game.")

@client.on(events.NewMessage(pattern='/wordle'))
async def play(event):
    user_id = event.sender_id
    
    # Start a new game for the user
    word = get_random_word()
    puzzle = create_puzzle(word)
    
    game_state[user_id] = {
        'word': word,
        'puzzle': puzzle,
        'revealed_indices': {i for i, letter in enumerate(puzzle) if letter != '_'},
        'username': event.sender.username
    }
    
    await event.respond(f"{event.sender.username}, Complete the word: **{puzzle}**", buttons=create_buttons())

@client.on(events.CallbackQuery)
async def callback(event):
    user_id = event.sender_id
    
    if user_id not in game_state:
        await event.answer("No active game found. Type /wordle to start a new game.")
        return

    chosen_letter = event.data.decode('utf-8')
    
    word = game_state[user_id]['word']
    puzzle = list(game_state[user_id]['puzzle'])
    revealed_indices = game_state[user_id]['revealed_indices']

    # Reveal all positions of the chosen letter
    if chosen_letter in word:
        for i, letter in enumerate(word):
            if letter == chosen_letter and i not in revealed_indices:
                puzzle[i] = chosen_letter
                revealed_indices.add(i)

        # Update the game state
        game_state[user_id]['puzzle'] = ''.join(puzzle)
        game_state[user_id]['revealed_indices'] = revealed_indices

        # Check if the puzzle is now complete
        if '_' not in puzzle:
            await event.answer(f"Correct! The word was **{word}**.", alert=True)
            await event.edit(f"🎉 **@{game_state[user_id]['username']}** completed the word: **{word}**! Type /wordle to start a new game.")
            
            # Update the leaderboard
            username = game_state[user_id]['username']
            leaderboard[username] = leaderboard.get(username, 0) + 10
            
            # Reset the game state for this user
            game_state.pop(user_id, None)
        else:
            await event.edit(f"Complete the word: **{''.join(puzzle)}**", buttons=create_buttons())
    else:
        await event.answer("Incorrect letter, try again!", alert=True)

@client.on(events.NewMessage(pattern='/lead'))
async def show_leaderboard(event):
    if not leaderboard:
        await event.respond("No one has completed a wordle yet!")
    else:
        sorted_leaderboard = sorted(leaderboard.items(), key=lambda x: x[1], reverse=True)
        leaderboard_text = "🏆 **Leaderboard** 🏆\n\n"
        for rank, (username, points) in enumerate(sorted_leaderboard, 1):
            leaderboard_text += f"{rank}. **{username}** - {points} points\n"
        await event.respond(leaderboard_text)

# Helper function to chunk list into batches of 5
def chunk_list(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]

@client.on(events.NewMessage(pattern='/utag'))
async def handler(event):
    # Check if the command is used in a group
    if event.is_group:
        sender = await event.get_sender()

        # Check if the sender is an admin
        admins = await client(GetParticipantsRequest(
            channel=event.chat_id,
            filter=ChannelParticipantsAdmins(),
            offset=0,
            limit=0,
            hash=0
        ))

        if sender.id not in [admin.id for admin in admins.users]:
            await event.reply("You are not 🚫 authorized to use this command.")
            return

        # Extract the reason if provided
        message_parts = event.message.text.split(' ', 1)
        reason = message_parts[1] if len(message_parts) > 1 else "Attention!"

        # Send confirmation message that tagging operation is starting
        await event.reply("Tagging operation started...")

        # Get all participants in the group
        participants = await client(GetParticipantsRequest(
            channel=event.chat_id,
            filter=ChannelParticipantsSearch(''),
            offset=0,
            limit=0,
            hash=0
        ))

        # Create the tags in batches of 5 users
        tagged_users = []
        for user in participants.users:
            if not user.bot:
                tagged_users.append(f"[{user.first_name}](tg://user?id={user.id})")

        # Send messages with 5 users per message
        for chunk in chunk_list(tagged_users, 5):
            await client.send_message(event.chat_id, f"{reason}\n" + ' '.join(chunk))
        
        # Send confirmation message that tagging operation is done
        await event.reply("Tagging all users done ✅✅")
    else:
        # If the command is used in a DM with the bot
        await event.reply("This command only works with groups.")

# Ban Command
@client.on(events.NewMessage(pattern='/ban'))
async def ban_user(event):
    if not event.is_group:
        await event.reply('This command only works with groups.')
        return

    # Check if the user is an admin
    admins = await bot.get_participants(event.chat_id, filter=ChannelParticipantsAdmins)
    if event.sender_id not in [admin.id for admin in admins]:
        await event.reply('You are not 🚫 authorised to use this command.')
        return

    # Check if the command is a reply to a user
    if not event.is_reply:
        await event.reply('Please reply to the user you want to ban.')
        return

    # Get the user to be banned
    reply_message = await event.get_reply_message()
    user_to_ban = await bot.get_entity(reply_message.sender_id)

    # Check if the user is an admin
    if user_to_ban.id in [admin.id for admin in admins]:
        await event.reply("I don't have the permission to Ban an Admin.")
        return

    # Check if the user is already banned
    try:
        banned_rights_current = await bot.get_permissions(event.chat_id, user_to_ban.id)
        if banned_rights_current.view_messages:
            await event.reply('This user is already Banned.')
            return
    except Exception:
        pass  # Ignore if the user is not found

    # Permanently ban the user
    ban_rights = ChatBannedRights(
        until_date=None,  # Permanent ban
        view_messages=True,  # User can't view messages (banned)
        send_messages=True,
        send_media=True,
        send_stickers=True,
        send_gifs=True,
        send_games=True,
        send_inline=True,
        embed_links=True,
        send_polls=True,
        change_info=True,
        invite_users=True,
        pin_messages=True
    )
    try:
        await bot(EditBannedRequest(event.chat_id, user_to_ban.id, ban_rights))
        await event.reply(f'{user_to_ban.first_name} has been banned 🚫 from the group.')
    except Exception as e:
        await event.reply(f'Failed to ban user: {str(e)}')

# Unban Command
@client.on(events.NewMessage(pattern='/unban'))
async def unban_user(event):
    if not event.is_group:
        await event.reply('This command only works with groups.')
        return

    # Check if the user is an admin
    admins = await bot.get_participants(event.chat_id, filter=ChannelParticipantsAdmins)
    if event.sender_id not in [admin.id for admin in admins]:
        await event.reply('You are not 🚫 authorised to use this command.')
        return

    # Check if the command is a reply to a banned user
    if not event.is_reply:
        await event.reply('Please reply to the user you want to unban.')
        return

    # Get the user to be unbanned
    reply_message = await event.get_reply_message()
    user_to_unban = await bot.get_entity(reply_message.sender_id)

    # Check if the user is an admin
    if user_to_unban.id in [admin.id for admin in admins]:
        await event.reply("Admins can't be Banned. So, how could I unban them?")
        return

    # Check if the user is banned
    try:
        banned_rights_current = await bot.get_permissions(event.chat_id, user_to_unban.id)
        if not banned_rights_current.view_messages:
            await event.reply('This user is not Banned in current status.')
            return
    except Exception:
        pass  # Ignore if the user is not found

    # Unban the user
    unban_rights = ChatBannedRights(
        until_date=None,
        view_messages=False  # Allow the user to view messages (unbanned)
    )
    try:
        await bot(EditBannedRequest(event.chat_id, user_to_unban.id, unban_rights))
        await event.reply(f'{user_to_unban.first_name} is now Unbanned. They can join again.')
    except Exception as e:
        await event.reply(f'Failed to unban user: {str(e)}')

# Monitor Join Attempts
@client.on(events.ChatAction())
async def monitor_join_attempt(event):
    if event.user_added or event.user_joined:
        user_id = event.user_id
        chat = await bot.get_entity(event.chat_id)
        
        try:
            # Check if the user is banned
            banned_rights_current = await bot.get_permissions(chat.id, user_id)
            if banned_rights_current.view_messages:
                # User is banned, so remove them and notify
                await bot.kick_participant(chat.id, user_id)
                user = await bot.get_entity(user_id)
                await bot.send_message(event.chat_id, f'{user.first_name} is Banned from this GroupChat. Unban them first to add them again.')
        except Exception as e:
            pass  # Ignore errors related to checking banned rights or removing users

@client.on(events.NewMessage(pattern='/pin'))
async def pin_message(event):
    # Check if the command is used in a group
    if not event.is_group:
        await event.reply("This command only works with groups")
        return
    
    # Get the sender's information
    sender = await event.get_sender()
    admin_rights = await client.get_permissions(event.chat_id, sender.id)
    
    # Check if the user is an admin
    if not admin_rights.is_admin:
        await event.reply("You're not 🚫 authorised to use this command")
        return

    # Check if the command is used in reply to a message
    if not event.reply_to_msg_id:
        await event.reply("Reply to a message first to Pin 📌 it")
        return
    
    try:
        # Pin the replied-to message
        await client.pin_message(event.chat_id, event.reply_to_msg_id)
        await event.reply("Message Pinned 📌 Successfully ✅")
    except Exception as e:
        await event.reply(f"Failed to pin the message. Error: {str(e)}")

@client.on(events.NewMessage(pattern='/unpin'))
async def unpin_message(event):
    # Check if the command is used in a group
    if not event.is_group:
        await event.reply("This command only works with groups")
        return
    
    # Get the sender's information
    sender = await event.get_sender()
    admin_rights = await client.get_permissions(event.chat_id, sender.id)
    
    # Check if the user is an admin
    if not admin_rights.is_admin:
        await event.reply("You're not 🚫 authorised to use this command")
        return

    # Check if the command is used in reply to a message
    if not event.reply_to_msg_id:
        await event.reply("Reply to a message to unpin it")
        return
    
    try:
        # Unpin the replied-to message
        await client.unpin_message(event.chat_id, event.reply_to_msg_id)
        await event.reply("Last message Unpinned successfully ✅")
    except Exception as e:
        await event.reply(f"Failed to unpin the message. Error: {str(e)}")

async def is_voice_chat_active(chat_id):
    """
    Check if there's an ongoing voice chat or live stream in the group.
    """
    full_chat = await client(GetFullChannelRequest(channel=chat_id))
    if full_chat.full_chat.call:
        return True
    return False

@client.on(events.NewMessage(pattern='/play(?: (.*))?'))
async def play_song(event):
    if event.is_private:
        await event.reply('This command only works with groups.')
        return
    
    chat = await event.get_chat()
    if not isinstance(chat, types.Chat) and not isinstance(chat, types.Channel):
        await event.reply('This command only works in groups and channels.')
        return
    
    if not await is_voice_chat_active(chat.id):
        await event.reply('Start a livestream to play ⏯️ songs.')
        return

    song_name = event.pattern_match.group(1)
    if not song_name:
        await event.reply('You need to specify a song to play it.')
        return

    # Search for the song on Spotify
    results = sp.search(q=song_name, type='track', limit=1)
    if results['tracks']['items']:
        track = results['tracks']['items'][0]
        track_url = track['external_urls']['spotify']
        track_name = track['name']
        track_artist = track['artists'][0]['name']

        # Simulate playing the song by replying with the track info
        await event.reply(f"Playing **{track_name}** by **{track_artist}**\n[Listen on Spotify]({track_url})")
    else:
        await event.reply('Sorry, I could not find the song you requested.')

client.start()
client.run_until_disconnected()
